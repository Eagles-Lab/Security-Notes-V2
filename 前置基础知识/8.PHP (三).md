# Day3 前置基础知识-PHP（三）

## 一、PHP函数基础

### 1. PHP函数概述：代码复用与功能模块化

#### 1.1 什么是PHP函数？

PHP函数是一段被命名的、可重复使用的代码块，能够接收输入参数、执行特定任务并返回结果。函数是程序设计中实现代码复用、提高开发效率、降低维护成本的重要工具。

在网络安全领域，函数的正确使用关系到应用程序的安全性：

- **输入验证函数**：确保用户输入的合法性
- **输出过滤函数**：防止XSS攻击
- **数据处理函数**：安全地处理敏感数据
- **权限验证函数**：控制用户访问权限

#### 1.2 PHP函数的分类

| 函数类型         | 说明                   | 示例                                | 安全特点                           |
| ---------------- | ---------------------- | ----------------------------------- | ---------------------------------- |
| **内置函数**     | PHP内置提供的函数      | `strlen()`, `mysql_connect()`       | 部分函数存在安全风险，需要谨慎使用 |
| **用户定义函数** | 开发者自定义的函数     | `validateInput()`, `sanitizeData()` | 安全性完全取决于实现质量           |
| **匿名函数**     | 没有名称的函数（闭包） | `function() { ... }`                | 常用于回调，注意作用域安全         |
| **可变函数**     | 通过变量调用的函数     | `$func = 'strlen'; $func();`        | ⚠️ 高风险，可能导致任意代码执行     |

### 2. PHP用户定义函数

### 2.1 函数定义语法

PHP用户定义函数使用 `function` 关键字定义，基本语法如下：

```
<?php
function 函数名(参数列表) {
    // 函数体
    return 返回值; // 可选
}
?>
```

#### 2.1.1 基本函数示例

```
<?php
    // 简单的问候函数
    function greet($name) {
        return "Hello, " . $name . "!";
    }
    
    // 调用函数
    echo greet("Alice"); // 输出: Hello, Alice!
    
    // 安全的用户输入验证函数
    function validateUsername($username) {
        // 检查是否为空
        if (empty($username)) {
            return false;
        }
        
        // 检查长度
        if (strlen($username) < 3 || strlen($username) > 20) {
            return false;
        }
        
        // 检查字符是否合法（只允许字母、数字、下划线）
        if (!preg_match('/^[a-zA-Z0-9_]+$/', $username)) {
            return false;
        }
        
        return true;
    }
    
    // 使用示例
    $userInput = "admin_123";
    if (validateUsername($userInput)) {
        echo "用户名验证通过";
    } else {
        echo "用户名格式不正确";
    }
?>
```

### 2.2 函数命名规范

良好的函数命名是代码可读性和安全性的基础：

| 命名类型   | 示例                                    | 说明             | 安全建议                           |
| ---------- | --------------------------------------- | ---------------- | ---------------------------------- |
| **动作型** | `validateInput()`, `sanitizeData()`     | 表示执行的动作   | 函数名应明确表示功能，避免歧义     |
| **判断型** | `isAdmin()`, `hasPermission()`          | 返回布尔值的判断 | 以is、has、can等开头，明确返回类型 |
| **获取型** | `getUserInfo()`, `getConfig()`          | 获取数据         | 明确获取的数据类型和来源           |
| **处理型** | `processPayment()`, `encryptPassword()` | 处理业务逻辑     | 函数名应反映处理的安全性质         |

### 2.3 函数的安全设计原则

#### 2.3.1 输入验证原则

```
<?php
    // 安全的邮箱验证函数
    function validateEmail($email) {
        // 1. 基础验证
        if (empty($email)) {
            return false;
        }
        
        // 2. 格式验证
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            return false;
        }
        
        // 3. 长度限制
        if (strlen($email) > 254) {
            return false;
        }
        
        // 4. 域名白名单（可选）
        $allowedDomains = ['gmail.com', 'yahoo.com', 'outlook.com'];
        $domain = substr(strrchr($email, "@"), 1);
        if (!empty($allowedDomains) && !in_array($domain, $allowedDomains, true)) {
            return false;
        }
        
        return true;
    }
    
    // 安全的密码强度验证函数
    function validatePasswordStrength($password) {
        $result = [
            'valid' => false,
            'score' => 0,
            'messages' => []
        ];
        
        // 长度检查
        if (strlen($password) < 8) {
            $result['messages'][] = '密码长度至少8位';
            return $result;
        } else {
            $result['score'] += 1;
        }
        
        // 复杂度检查
        if (preg_match('/[a-z]/', $password)) $result['score'] += 1; // 小写字母
        if (preg_match('/[A-Z]/', $password)) $result['score'] += 1; // 大写字母
        if (preg_match('/[0-9]/', $password)) $result['score'] += 1; // 数字
        if (preg_match('/[^a-zA-Z0-9]/', $password)) $result['score'] += 1; // 特殊字符
        
        // 评分
        if ($result['score'] >= 3) {
            $result['valid'] = true;
            $result['messages'][] = '密码强度良好';
        } else {
            $result['messages'][] = '密码需要包含大小写字母、数字和特殊字符';
        }
        
        return $result;
    }
?>
```

## 二、PHP正则表达式

### 1. 正则表达式基础概念

#### 1.1 什么是正则表达式
**正则表达式**（Regular Expression，简称 **Regex**）是一种强大的文本处理工具，它通过一个“模式”来描述字符串的规则。我们可以使用这个模式去：

- 检查某个字符串是否符合特定格式
- 从一段文本中提取我们感兴趣的内容
- 替换或分割字符串

>  简单理解：正则就像是“文字的搜索语法升级版”，不仅能搜“hello”，还能搜“以h开头、后面跟着3个数字、再以.com结尾”的内容。

#### 1.2 常见应用场景

| 场景     | 示例                                                    |
| :------- | :------------------------------------------------------ |
| 表单验证 | 验证手机号、邮箱、身份证号等输入是否合法                |
| 日志分析 | 提取日志中的IP地址、错误代码、时间戳                    |
| 批量处理 | 在编辑器中批量替换代码格式（如 `function()` → `() =>`） |
| 网络爬虫 | 从HTML中提取链接、标题、价格等信息                      |
| 数据清洗 | 清理杂乱数据中的无效字符或空格                          |

💡 小贴士：你在 VS Code、PyCharm 或 Word 中使用“查找替换”时勾选了“使用正则”，就已经在用它了！

#### **1.3 基础语法**

**基础元字符（原子单位）**

| 符号 | 含义                               | 示例说明                           |
| :--- | :--------------------------------- | :--------------------------------- |
| `.`  | 匹配任意一个字符（除换行外）       | `a.c` → 可匹配 `abc`, `a1c`, `a c` |
| `\d` | 匹配一个数字（0–9）                | `\d\d` → 匹配 `12`, `99`           |
| `\w` | 匹配字母、数字或下划线             | `\w+` → 匹配 `user_123`            |
| `\s` | 匹配空白字符（空格、制表符、换行） | `a\sb` → 匹配 `"a b"`              |
| `^`  | 匹配字符串开始位置                 | `^Hello` → 必须出现在开头          |
| `$`  | 匹配字符串结束位置                 | `world$` → 必须出现在结尾          |

练习：写出能匹配 “4位年份” 的正则？
`\d{4}`

`^\d{4}$`

**量词（重复次数控制）**

| 量词    | 含义             | 示例说明                               |
| :------ | :--------------- | :------------------------------------- |
| `*`     | 出现 0 次或多次  | `ab*` → 匹配 `a`, `ab`, `abb`          |
| `+`     | 出现 1 次或多次  | `ab+` → 不匹配 `a`，但匹配 `ab`, `abb` |
| `?`     | 出现 0 次或 1 次 | `https?` → 匹配 `http` 和 `https`      |
| `{n}`   | 精确出现 n 次    | `\d{3}` → 匹配 `123`                   |
| `{n,}`  | 至少出现 n 次    | `\d{2,}` → 匹配 `12`, `12345`          |
| `{n,m}` | 出现 n 到 m 次   | `\d{2,4}` → 匹配 `12`, `123`, `1234`   |

注意区别：

- `.*`：尽可能多地匹配任意字符（贪婪）
- `.*?`：尽可能少地匹配（非贪婪），常用于提取中间内容

| 模式  | 名称           | 匹配策略                                         | 类比                       |
| ----- | -------------- | ------------------------------------------------ | -------------------------- |
| `.*`  | **贪婪匹配**   | **尽可能多吃**，一直匹配到字符串末尾，再回溯     | 贪吃蛇，先吃撑再吐出来     |
| `.*?` | **非贪婪匹配** | **尽可能少吃**，一旦满足条件立即停，让后续先匹配 | 礼貌者，够吃就行，留给别人 |

**为什么 `.*?` 适合提取中间内容？**

看一个实际例子：提取 HTML 标签中的内容

```html
<div>内容1</div><div>内容2</div>
```

**贪婪匹配 `.*` 的问题**

正则：`<div>.*</div>`

- **匹配过程**：`<div>` 匹配后，`.` 会一直吞下所有字符到字符串结尾，再回溯找 `</div>`
- **结果**：**匹配整个字符串** `<div>内容1</div><div>内容2</div>` 

**非贪婪匹配 `.*?` 的优势**

正则：`<div>.*?</div>`

- **匹配过程**：`<div>` 匹配后，`.` 只吞一个字符就检查 `</div>` 是否能匹配
- **结果**：**匹配到第一个 `</div>`** 就停止，得到 `<div>内容1</div>`

**字符集合与分组**

（1）字符类 `[...]`

表示匹配其中任意一个字符。

| 示例              | 含义                                     |
| :---------------- | :--------------------------------------- |
| `[aeiou]`         | 匹配任意一个元音字母                     |
| `[A-Z]`           | 匹配大写字母 A~Z                         |
| `[0-9a-f]`        | 匹配十六进制数字                         |
| `[^0-9]`          | `^` 在 \[ ] 内表示“非”，即不是数字的字符 |
| `[a-zA-Z]`        | 匹配所有大小写字母                       |
| `[0-9]`           | 等价于 `\d`，匹配任意数字                |
| `[\w]`            | 等价于 `[A-Za-z0-9_]`，匹配单词字符      |
| `[\s]`            | 匹配任意空白符（空格、制表符、换行）     |
| `[.,;:!]`         | 匹配常见标点符号                         |
| `[a-fA-F]`        | 匹配十六进制字母（大小写）               |
| `[\u4e00-\u9fa5]` | 匹配中文字符范围                         |
| `[\p{Han}]`       | Unicode方式匹配汉字（部分语言支持）      |
| `[a-z-]`          | 在末尾的 `-` 表示字面连字符              |
| `[\[\]]`          | 匹配方括号本身 `[` 或 `]`                |
| `[^aeiou]`        | 匹配任意非元音字符                       |
| `[/\\]`           | 匹配路径分隔符 `/` 或 `\`                |

（2）分组 `( ... )`

将多个字符组合成一个整体，并可用于捕获内容。

| 示例                      | 说明                                        |
| :------------------------ | :------------------------------------------ |
| `(abc)+`                  | 匹配 `abc`, `abcabc`                        |
| `(\d{4})-(\d{2})-(\d{2})` | 可分别捕获年、月、日部分（如 `2025-04-05`） |

捕获后可用编程语言获取各组内容，比如 Python 中的 `group(1)`。

#### 1.4 进阶使用

**替换（Replace）**

用正则找到目标，替换成新内容。

 示例：将所有连续空格变为单个下划线
原文：`"hello world python"`
正则：`\s+`
替换为：`_`
结果：`hello_world_python`

**验证电子邮箱**

 要求：用户名@域名.后缀
例如：`student@school.edu.cn`

分析结构：

- 用户名：字母、数字、点、下划线等 → `[\w._%+-]+`
- @ 符号固定
- 域名：字母、数字、连字符 → `[a-zA-Z0-9.-]+`
- 后缀：至少两个字母 → `\.[a-zA-Z]{2,}`

 最终正则：

```regex
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
```

**提取网页链接**

HTML 片段：

```html
<a href="https://www.baidu.com">百度</a>
<a href="https://www.taobao.com">淘宝</a>
```

目标：提取所有 URL

正则：

```regex
<a href="(.*?)">
```

Python 提取代码：

```python
import re

html = '''
<a href="https://baidu.com">百度</a>
<a href="https://taobao.com">淘宝</a>
'''

urls = re.findall(r'<a href="(.*?)">', html)#re.findall() 默认返回所有捕获组（group1、group2...）。
print(urls)  # 输出: ['https://baidu.com', 'https://taobao.com']，
print(urls[0]) #输出：https://baidu.com
print(urls[1]) #输出：https://taobao.com
```

解释：`(.*?)` 使用非贪婪模式，确保只取引号内的内容。

#### 正则实验：

**练习 1：匹配江苏大学 / 江苏科技大学邮箱**

**需求：**
 能同时匹配

- `xxx@ujs.edu.cn`（江苏大学）
- `xxx@just.edu.cn`（江苏科技大学）

**练习 2：匹配中国大陆 11 位手机号**

**分别写出下面两种格式的正则：**

- 如果手机号格式必须是正规 1 开头 11 位怎么写正则？
- 如果允许写成：`+86 13812345678`怎么写正则？

**练习 3：匹配镇江地区固定电话**

**需求：**

镇江地区区号：`0511`
 格式要求： `0511-xxxxxxxx`（8 位数字）

**练习 4：提取 URL 中的协议 + 域名**

匹配http或者https如：

- `https://www.baidu.com`
- `http://example.org`



**示例：**

练习1：

```regex
^[A-Za-z0-9._-]+@(ujs|just)\.edu\.cn$
```

测试

| 测试字符串            | 结果     |
| --------------------- | -------- |
| `abc@ujs.edu.cn`      | ✔ 匹配   |
| `test123@just.edu.cn` | ✔ 匹配   |
| `aaa@nju.edu.cn`      | ✖ 不匹配 |

练习2：

普通 11 位号码：

```
^1[3-9]\d{9}$
```

支持 +86- 前缀

```
^(?:\+86\s?)?1[3-9]\d{9}$
```

`(?:...)` 表示非捕获组，前缀可有可无。

测试

| 输入              | 匹配？ |
| ----------------- | ------ |
| `13812345678`     | ✔      |
| `18800001234`     | ✔      |
| `+86 13988886666` | ✔      |
| `861388889999`    | ✖      |

练习3：

```regex
^0511-\d{8}$
```

测试

| 输入            | 匹配？            |
| --------------- | ----------------- |
| `0511-88881234` | ✔                 |
| `0511-1234567`  | ✖（只有7位）      |
| `0510-12345678` | ✖（不是镇江区号） |

练习4：

```regex
^(https?)://[A-Za-z0-9.-]+$
```

测试

| 输入                    | 匹配？ |
| ----------------------- | ------ |
| `https://www.baidu.com` | ✔      |
| `ftp://abc.com`         | ✖      |
| `www.baidu.com`         | ✖      |

### 2. PHP正则表达式语法基础

PHP使用PCRE（Perl兼容正则表达式）库，基本语法结构：
```php
/pattern/modifiers
```

**常用元字符：**

- `.` : 匹配任意单个字符（除换行符）
- `*` : 匹配前面字符0次或多次
- `+` : 匹配前面字符1次或多次
- `?` : 匹配前面字符0次或1次
- `^` : 匹配字符串开始
- `$` : 匹配字符串结束
- `[]` : 字符类，匹配括号内任意一个字符
- `()` : 分组，用于提取子匹配

**常用修饰符：**
- `i` : 忽略大小写
- `m` : 多行模式
- `s` : 单行模式（.匹配包括换行符）
- `u` : UTF-8模式
- `x` : 忽略空白字符和注释

 **`i` — 忽略大小写（case-insensitive）**

不使用 i（默认大小写敏感）：

```
preg_match('/abc/', 'ABC'); // ❌ 不匹配
```

使用 i：

```
preg_match('/abc/i', 'ABC'); // ✅ 匹配成功
```

**用途**：匹配不区分大小写的邮箱、用户名、标签等。

 **`m` — 多行模式（multiline）**

让 **^ 和 $ 可以匹配每一行的开头和结尾**（不是整个字符串）。

示例文本（多行）：

```
hello
world
```

正则：

```
preg_match_all('/^world/m', $text);
```

`m` 打开后：

- `^world` 会匹配第二行的开头
- 否则不会

**不加 m：**
 `^world` 只能匹配字符串整体开头（第一行），不会匹配第二行。

**用于处理多行文本、日志文件、代码匹配等。**

 **`s` — 单行模式（dot-all）**

让 `.` 能匹配换行符 `\n`。

默认情况下：

```
preg_match('/a.*b/', "a\nb"); // ❌ 不匹配
```

因为 `.` 不会匹配换行。

启用 s：

```
preg_match('/a.*b/s', "a\nb"); // ✅ 匹配
```

**用途：**

- 处理跨行文本匹配
- 解析 HTML（不推荐用正则……但有人会这么做）
- 解析 JSON 字符串

 **`u` — UTF-8 模式（最重要之一）**

让正则把字符串当成 **UTF-8 字符** 处理。

不加 u 时：

```
preg_match('/./', '中'); // ❌ 会匹配乱码（因为 . 抓 1 byte）
```

加上 u 后：

```
preg_match('/./u', '中'); // ✅ 匹配 1 个中文字符
```

**用途：**

- 中文、日文、韩文匹配
- 任意 Unicode 字符
- 处理 emoji

例如匹配中文字符：

```
preg_match('/[\x{4e00}-\x{9fa5}]+/u', $str);//匹配任意一个介于 U+4E00 到 U+9FA5 的中文汉字。
```

没有 `u` 根本无法正常工作。

 **`x` — 忽略空白 + 允许注释（extended mode）**

打开后可以写“可读性更强的正则”，空格会被忽略。

例如：

```
$pattern = '/
  ^                # 开头
  [a-z0-9._%+-]+   # 用户名
  @
  [a-z0-9.-]+      # 域名主体
  \.
  [a-z]{2,}        # 顶级域名
 $                 # 结尾
/xi';              // x = 忽略空白，i = 忽略大小写
```

注意：

- 这里面的空格不会计入正则意义
- `#` 后面是注释
- 用于书写复杂正则特别好用

**不开 x 时：**
 写这些空格正则就会报错或匹配失败。

### 3. preg_match()函数详解

#### 3.1 函数语法
```php
preg_match($pattern, $subject, &$matches = null, $flags = 0, $offset = 0)
```

**参数说明：**

- `$pattern`: 正则表达式模式
- `$subject`: 要搜索的字符串
- `$matches`: 存储匹配结果的数组
- `$flags`: 可选标志
- `$offset`: 搜索开始位置

#### 3.2 基本使用示例
```php
<?php
// 验证邮箱格式
function validateEmail($email) {
    $pattern = '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/';
    return preg_match($pattern, $email);
}

// 测试邮箱验证
$emails = [
    'test@example.com',
    'invalid-email',
    'user.name+tag@domain.co.uk'
];

foreach ($emails as $email) {
    if (validateEmail($email)) {
        echo "有效邮箱: $email\n";
    } else {
        echo "无效邮箱: $email\n";
    }
}

// 提取匹配内容
$text = "联系电话：138-1234-5678";
$pattern = '/(\d{3})-(\d{4})-(\d{4})/';
if (preg_match($pattern, $text, $matches)) {
    echo "完整匹配: " . $matches[0] . "\n";
    echo "区号: " . $matches[1] . "\n";
    echo "前四位: " . $matches[2] . "\n";
    echo "后四位: " . $matches[3] . "\n";
}
?>
```

#### 3.3 安全应用场景
```php
<?php
// 安全的用户名验证
function validateUsername($username) {
    // 只允许字母、数字、下划线，长度3-20位
    $pattern = '/^[a-zA-Z0-9_]{3,20}$/';
    return preg_match($pattern, $username);
}

// 过滤危险字符
function filterDangerousChars($input) {
    // 检测潜在的脚本注入
    $dangerousPattern = '/<script|javascript:|onload=|onerror=/i';
    if (preg_match($dangerousPattern, $input)) {
        return false; // 发现危险内容
    }
    return true;
}

// 验证IP地址
function validateIP($ip) {
    $pattern = '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/';
    return preg_match($pattern, $ip);
}
?>
```

### 4. preg_match_all()函数详解

#### 4.1 函数语法
```php
preg_match_all($pattern, $subject, &$matches = null, $flags = PREG_PATTERN_ORDER, $offset = 0)
```

参数说明

| 参数         | 说明                                         |
| ------------ | -------------------------------------------- |
| **$pattern** | 正则表达式模式（需由定界符包裹，如 `/.../`） |
| **$subject** | 要搜索的目标字符串                           |
| **$matches** | 用于存储所有匹配结果的数组（二维数组）       |
| **$flags**   | 匹配结果的排序方式（可选）                   |
| **$offset**  | 从字符串的第几个字符开始搜索（可选）         |

`$flags` 常用标志说明

| 标志                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| **PREG_PATTERN_ORDER**（默认）    | 第一次括号捕获的所有结果放在 `$matches[1]`，第二次捕获的结果放 `$matches[2]`，依次类推。 |
| **PREG_SET_ORDER**                | 每一次完整匹配作为一个数组，按顺序放在 `$matches[0]`、`$matches[1]`... |
| **PREG_OFFSET_CAPTURE**           | 返回每个匹配结果的 **位置索引**（每个结果变为 `[匹配文本, 位置]`） |
| 标志可以组合，如：`PREG_SET_ORDER | PREG_OFFSET_CAPTURE`                                         |

**核心特点（与 `preg_match()` 的区别）**

| 函数                 | 匹配次数          | 返回内容                  |
| -------------------- | ----------------- | ------------------------- |
| **preg_match()**     | 只匹配 **第一个** | 存 `$matches` 中          |
| **preg_match_all()** | 匹配 **全部**     | 存二维数组 `$matches[][]` |

使用场景举例：

- 获取所有邮箱、所有 URL、所有数字、所有标签
- 批量解析文本内容
- 日志、文本抽取

**示例：提取所有数字**

示例代码

```
<?php 
$str = "订单 101 到达仓库，订单 202 已发货，订单 303 已签收。";
preg_match('/\d+/', $str, $matches1);
preg_match_all('/\d+/', $str, $matches2);

print_r($matches1);
print_r($matches2);
?>
```

输出：

```php
Array
(
    [0] => 101
)


Array
(
    [0] => Array
        (
            [0] => 101
            [1] => 202
            [2] => 303
        )
)
```

#### 4.2 基本使用示例

```php
<?php
// 提取所有邮箱地址
$text = "联系人：张三 zhang@company.com，李四 li@example.org，王五 wang@test.cn";
$pattern = '/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/';

if (preg_match_all($pattern, $text, $matches)) {
    echo "找到 " . count($matches[0]) . " 个邮箱地址：\n";
    print_r($matches);
    foreach ($matches[0] as $email) {
        echo "- $email\n";
    }
}

// 提取所有链接
$html = '<a href="http://example.com">链接1</a> <a href="https://test.org">链接2</a>';
$pattern = '/href="([^"]+)"/';

if (preg_match_all($pattern, $html, $matches)) {
    echo "找到的链接：\n";
    foreach ($matches[1] as $url) {
        echo "- $url\n";
    }
}
?>
```

### 5. preg_filter()函数详解

#### 5.1 函数语法
```php
preg_filter($pattern, $replacement, $subject, $limit = -1, &$count = null)
```

**参数说明**

| 参数             | 说明                                 |
| ---------------- | ------------------------------------ |
| **$pattern**     | 正则表达式（可以是数组）             |
| **$replacement** | 替换内容（可以是数组）               |
| **$subject**     | 进行匹配和替换的目标字符串/数组      |
| **$limit**       | 替换次数，默认 -1 表示不限制         |
| **&$count**      | 返回实际替换了多少次（变量会被赋值） |

**函数作用**

**preg_filter() 与 preg_replace() 的区别是：preg_filter() 会返回 “仅仅有替换”的结果，如果没有匹配到任何内容，会返回 `null`。**

而 preg_replace() 即使没有任何替换，也会返回原字符串。

**与 preg_replace() 的区别（重点）**

| 函数               | 无匹配时的返回值 |
| ------------------ | ---------------- |
| **preg_replace()** | 返回原字符串     |
| **preg_filter()**  | 返回 **null**    |

举个例子就很清楚：

**preg_replace() 示例**

```
$result = preg_replace('/a/', 'X', 'hello');
var_dump($result);
```

输出：

```
string(5) "hello"   // 没有匹配, 仍然返回原字符串
```

**preg_filter() 示例**

```
$result = preg_filter('/a/', 'X', 'hello');
var_dump($result);
```

输出：

```
NULL    // 没匹配到 a ，直接返回 null
```

------

#### **5.2 基本使用示例**

**示例 1：正常替换**

```
$str = "apple banana";
$result = preg_filter('/a/', 'X', $str, -1, $count);

echo $result;   // Xpple bXnXnX
echo "\n替换次数：$count";   // 替换了 5 次
```

**示例2： 数组替换示例**

preg_filter 可以对数组整体处理：

```
$input = ['cat', 'dog', 'pig'];
$result = preg_filter('/[aeiou]/', '*', $input);
print_r($result);
```

输出：

```
Array
(
    [0] => c*t
    [1] => d*g
    [2] => p*g
)
```

**没匹配就返回 null 的实际应用场景**

你可以用 preg_filter 来做：

- **判断是否替换成功**（因为 null = 没匹配）
- **筛选数组中含某字符串的项**（只匹配的才会被返回）

示例：筛选数组里是否有包含数字的项：

```
$data = ['abc', '123', 'hello9'];
$result = preg_filter('/\d/', '#', $data);

print_r($result);
```

输出：

```
Array
(
    [1] => ###
    [2] => hello#
)
```

未匹配的项（index 0: 'abc'）直接不出现在结果中。

### 6. preg_split()函数详解

#### 6.1 函数语法
```php
preg_split($pattern, $subject, $limit = -1, $flags = 0)
```

**参数说明**

| 参数         | 说明                                 |
| ------------ | ------------------------------------ |
| **$pattern** | 正则表达式（分隔规则）               |
| **$subject** | 要进行分割的字符串                   |
| **$limit**   | 返回结果的最大数量（默认 -1 不限制） |
| **$flags**   | 分割行为的控制标志（可选）           |

**函数作用**

**preg_split() 用正则表达式作为分隔符，将字符串拆分成数组。**

例如，可以用空白符、多个符号、数字、中文等各种规则来分割文本。

------

#### **6.2 基本使用示例**

**示例 1：按空格分割**

```
$str = "apple banana cherry";
$result = preg_split('/\s+/', $str);

print_r($result);
```

输出：

```
Array
(
    [0] => apple
    [1] => banana
    [2] => cherry
)
```

**示例 2：按多个符号分割**

如用 `,` 或 `;` 分割：

```
$str = "a,b;c,d;e";
$result = preg_split('/[,;]+/', $str);

print_r($result);
```

输出：

```
Array
(
    [0] => a
    [1] => b
    [2] => c
    [3] => d
    [4] => e
)
```

**示例 3：按数字分割**

```
$str = "apple1banana23cherry";
$result = preg_split('/\d+/', $str);

print_r($result);
```

输出：

```
Array
(
    [0] => apple
    [1] => banana
    [2] => cherry
)
```

------

#### **6.3 limit 参数示例**

限制拆分后的数组长度。

```
$str = "a b c d e";
$result = preg_split('/\s+/', $str, 3);

print_r($result);
```

输出：

```
Array
(
    [0] => a
    [1] => b
    [2] => c d e
)
```

前 2 次正常分割，第 3 个元素包含了剩余全部内容。

------

#### **6.4 flags 参数实战**

flags 可以控制是否保留分隔符、是否过滤空结果等。常用 flags：

| 标志                          | 说明                       |
| ----------------------------- | -------------------------- |
| **PREG_SPLIT_NO_EMPTY**       | 不返回空字符串             |
| **PREG_SPLIT_DELIM_CAPTURE**  | 返回捕获分组（保留分隔符） |
| **PREG_SPLIT_OFFSET_CAPTURE** | 返回每段的起始位置         |

**示例 1：PREG_SPLIT_NO_EMPTY（跳过空字符串）**

```
$str = "a,,b,,,c";
$result = preg_split('/,+/', $str, -1, PREG_SPLIT_NO_EMPTY);

print_r($result);
Array
(
    [0] => a
    [1] => b
    [2] => c
)
```

**示例 2：PREG_SPLIT_DELIM_CAPTURE（保留分隔符）**

```
$str = "a,b;c";
$result = preg_split('/([,;])/', $str, -1, PREG_SPLIT_DELIM_CAPTURE);

print_r($result);
```

输出：

```
Array
(
    [0] => a
    [1] => ,
    [2] => b
    [3] => ;
    [4] => c
)
```

捕获分组被返回了。

**示例 3：PREG_SPLIT_OFFSET_CAPTURE（返回每段的起始位置）**

```
$str = "apple banana";
$result = preg_split('/\s+/', $str, -1, PREG_SPLIT_OFFSET_CAPTURE);

print_r($result);
```

输出：

```
Array
(
    [0] => Array ( [0] => apple  [1] => 0 )
    [1] => Array ( [0] => banana [1] => 6 )
)
```

每项包含：

- 元素内容
- 在字符串中的位置

### 7. 实战应用

#### 7.1 实验整体要求

**任务：编写一个 PHP 脚本，从一段文本中：**
 ① 验证邮箱格式
 ② 提取所有手机号
 ③ 提取所有 URL
 ④ 提取 HTML 标签内容（非贪婪 `.*?`）
 ⑤ 输出匹配结果

#### **7.2 实验文本**

```php
$text = "
联系邮箱：zhangsan@ujs.edu.cn、lisi@just.edu.cn
错误邮箱：abc#qq.com

联系电话：13812345678 和 +86 13988886666

访问链接：
<a href=\"https://www.baidu.com\">百度</a>
<a href=\"http://example.org\">示例</a>

测试标签内容：<div>内容一</div><div>内容二</div>
";
```

#### **7.3 实验内容**

补全下面的代码，实现以下功能：

**① 验证邮箱是否为 ujs/just 邮箱（preg_match）**

**要求正则：**

```
xxx@ujs.edu.cn 或 xxx@just.edu.cn
```

目标：从文本中找到所有邮箱，逐个判断是否为有效校园邮箱。

**② 提取所有中国大陆手机号（preg_match_all）**

**要求同时支持：**

- `13812345678`
- `+86 13988886666`

**③ 提取所有 URL 超链接**

提取 `<a href="...">` 中的 URL
 （`(.*?)` 非贪婪匹配）

**④ 提取所有 div 标签中的内容**

例如：

```
<div>内容一</div>
<div>内容二</div>
```

应输出：

- 内容一
- 内容二

####  **7.4 实验主程序**

```php
<?php

$text = "
联系邮箱：zhangsan@ujs.edu.cn、lisi@just.edu.cn
错误邮箱：abc#qq.com

联系电话：13812345678 和 +86 13988886666

访问链接：
<a href=\"https://www.baidu.com\">百度</a>
<a href=\"http://example.org\">示例</a>

测试标签内容：<div>内容一</div><div>内容二</div>
";

echo "===== ① 校园邮箱验证 =====\n";

$emailPattern = '/在此处填写/u';  // 要补
preg_match_all($emailPattern, $text, $emails);

foreach ($emails[0] as $email) {
    if (preg_match('/这里写校园邮箱正则/u', $email)) {
        echo "有效校园邮箱：$email\n";
    } else {
        echo "无效邮箱：$email\n";
    }
}

echo "\n===== ② 提取手机号 =====\n";
$phonePattern = '/在此处填写/u'; // 要补
preg_match_all($phonePattern, $text, $phones);
print_r($phones[0]);


echo "\n===== ③ 提取所有 URL =====\n";
$urlPattern = '/在此处填写/u'; // 要补
preg_match_all($urlPattern, $text, $urls);
print_r($urls[1]);  // 只输出捕获组（URL）


echo "\n===== ④ 提取 div 标签内容 =====\n";
$divPattern = '/在此处填写/u'; // 要补
preg_match_all($divPattern, $text, $divs);
print_r($divs[1]);

?>
```

#### 7.5 示例答案及输出：

```php
<?php

$text = "
联系邮箱：zhangsan@ujs.edu.cn、lisi@just.edu.cn
错误邮箱：abc#qq.com

联系电话：13812345678 和 +86 13988886666

访问链接：
<a href=\"https://www.baidu.com\">百度</a>
<a href=\"http://example.org\">示例</a>

测试标签内容：<div>内容一</div><div>内容二</div>
";

echo "===== ① 校园邮箱验证 =====\n";

// 1. 提取所有邮箱
$emailPattern = '/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/u';
preg_match_all($emailPattern, $text, $emails);

foreach ($emails[0] as $email) {
    // 2. 判断是否为 ujs/just 校园邮箱
    if (preg_match('/^[A-Za-z0-9._-]+@(ujs|just)\.edu\.cn$/u', $email)) {
        echo "有效校园邮箱：$email\n";
    } else {
        echo "无效邮箱：$email\n";
    }
}

echo "\n===== ② 提取手机号 =====\n";
// 支持 138xxxxxxx 或 +86 138xxxxxxx
$phonePattern = '/(?:\+86\s?)?1[3-9]\d{9}/';
preg_match_all($phonePattern, $text, $phones);
print_r($phones[0]);

echo "\n===== ③ 提取所有 URL =====\n";
// 非贪婪匹配 href 中的内容
$urlPattern = '/<a href="(.*?)">/';
preg_match_all($urlPattern, $text, $urls);
print_r($urls[1]);  // 捕获组1即 URL

echo "\n===== ④ 提取 div 标签内容 =====\n";
// 非贪婪匹配 div 标签内容
$divPattern = '/<div>(.*?)<\/div>/u';
preg_match_all($divPattern, $text, $divs);
print_r($divs[1]);

?>
```

**输出结果示例**

```php
===== ① 校园邮箱验证 =====
有效校园邮箱：zhangsan@ujs.edu.cn
有效校园邮箱：lisi@just.edu.cn
无效邮箱：abc#qq.com

===== ② 提取手机号 =====
Array
(
    [0] => 13812345678
    [1] => +86 13988886666
)

===== ③ 提取所有 URL =====
Array
(
    [0] => https://www.baidu.com
    [1] => http://example.org
)

===== ④ 提取 div 标签内容 =====
Array
(
    [0] => 内容一
    [1] => 内容二
)
```

## 三、PHP连接MySQL数据库

### 1. 基本概念

PHP连接MySQL的三种方式：

1. **MySQL扩展**（已废弃，PHP 7.0+移除）
2. **MySQLi扩展**（MySQL Improved，支持面向对象和过程化）
3. **PDO**（PHP Data Objects，支持多种数据库，推荐使用）

### 2. 连接方式详解

#### 2.1 方式1：MySQLi（面向对象）

```php
<?php
// 1. 创建连接
$servername = "localhost";
$username = "root";
$password = "";
$dbname = "test_db";

$conn = new mysqli($servername, $username, $password, $dbname);

// 2. 检测连接
if ($conn->connect_error) {
    die("连接失败: " . $conn->connect_error);
}
echo "连接成功";

// 3. 设置字符集
$conn->set_charset("utf8mb4");

// 4. 关闭连接
$conn->close();
?>
```

#### 2.2 方式2：MySQLi（过程化）

```php
<?php
$conn = mysqli_connect($servername, $username, $password, $dbname);
if (!$conn) {
    die("连接失败: " . mysqli_connect_error());
}
mysqli_set_charset($conn, "utf8mb4");
mysqli_close($conn);
?>
```

**关键函数解析**

| 函数                     | 作用          | 示例                                       |
| :----------------------- | :------------ | :----------------------------------------- |
| `mysqli_connect()`       | 建立MySQL连接 | `mysqli_connect($host, $user, $pass, $db)` |
| `mysqli_connect_error()` | 获取错误信息  | 用于调试连接失败原因                       |
| `mysqli_close($conn)`    | 关闭连接      | 防止资源泄漏                               |

📌 **务必强调**：每次连接后都要做错误检查！

#### 2.3 方式3：PDO（推荐使用）

```php
<?php
try {
    $dsn = "mysql:host=$servername;dbname=$dbname;charset=utf8mb4";
    $options = [
        PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION, // 异常模式
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,       // 关联数组
        PDO::ATTR_EMULATE_PREPARES   => false,                  // 使用原生预处理
    ];
    $pdo = new PDO($dsn, $username, $password, $options);
    echo "PDO连接成功";
} catch(PDOException $e) {
    die("连接失败: " . $e->getMessage());
}
?>
```

### 3.危险写法

**❌ 危险写法（禁止使用）**

```php
$user = $_POST['username'];
$pass = $_POST['password'];
$sql = "SELECT * FROM users WHERE username='$user' AND password='$pass'";
$result = mysqli_query($conn, $sql); // 存在SQL注入风险！
```

> ⚠️ 攻击示例：输入用户名 `' OR 1=1 --` 可绕过登录验证！

**安全版本**

```php
// 获取用户输入
$user = $_POST['username'];
$pass = $_POST['password'];

// 使用预处理语句（Prepared Statement）
//创建一个 预处理语句（prepared statement）。SQL 里用 ? 作为占位符（placeholder），表示“这里后面会绑定具体的值”。把 SQL 的结构先发给数据库解析，把结构和数据分离，这是防止 SQL 注入的关键步骤。
$stmt = $conn->prepare("SELECT * FROM users WHERE username = ? AND password = ?");

// 绑定参数（s = string）
//把 PHP 变量绑定到上面 SQL 的占位符上：第一个 ? 绑定 $user，第二个 ? 绑定 $pass。"ss" 表示两个参数都是字符串（s = string）。bind_param 会确保这些值作为纯数据传给数据库，不会被当作 SQL 语句的一部分。
$stmt->bind_param("ss", $user, $pass);

// 执行 SQL,执行预处理语句。此时数据库使用已解析好的 SQL 结构，并把绑定的数据代入执行，返回结果集（如果是 SELECT）或受影响行数（如果是 UPDATE/DELETE）。
$stmt->execute();

// 获取结果
$result = $stmt->get_result();

// 判断用户是否存在
//检查结果集中是否至少有一行数据：如果有（num_rows > 0），说明找到了匹配的用户名 + 密码组合 —— 认为“登录成功”。否则说明没有匹配项，输出“用户名或密码错误”。
if ($result->num_rows > 0) {
    echo "登录成功";
} else {
    echo "用户名或密码错误";
}
```

**进阶版本**

注册时（示例 — 存哈希）

```php
$hash = password_hash($pass, PASSWORD_DEFAULT);
// INSERT INTO users (username, password) VALUES ('$user', '$hash');
```

登录时（安全对比版本）

```php
// 获取用户输入
$user = $_POST['username'];
$pass = $_POST['password'];

// 使用预处理语句：只根据用户名查询（不要用密码做条件）
$stmt = $conn->prepare("SELECT password FROM users WHERE username = ?");

// 绑定参数
$stmt->bind_param("s", $user);

// 执行 SQL
$stmt->execute();

// 获取查询结果
$result = $stmt->get_result();

// 判断用户是否存在
if ($result->num_rows === 1) {
    // 取出数据库中的哈希密码
    $row = $result->fetch_assoc();
    $hash = $row['password'];

    // 使用 password_verify 比对密码
    if (password_verify($pass, $hash)) {
        echo "登录成功";
    } else {
        echo "用户名或密码错误";
    }

} else {
    echo "用户名或密码错误"; // 用户名不存在
}
```

 为什么这样更安全？

**① password_hash()**

生成不可逆的哈希，数据库泄露也无法反查明文。

**② password_verify()**

自动处理加盐/成本因子/算法升级，无需人工写逻辑。

### 4.数据库连接小实验

**实验目标：**

1. 学会使用 HTML 创建简单的登录表单
2. 学会使用 PHP 获取 POST 表单数据
3. 学会使用 mysqli 连接 MySQL
4. 理解预处理语句防止 SQL 注入
5. 完成一次真实的“登录校验”流程

**最终效果：**

- 用户访问 `login.html` 输入用户名和密码
- PHP 后端到数据库检查是否存在匹配的账号
- 如果正确 → 显示“登录成功”
- 如果错误 → 显示“用户名或密码错误”

**数据库要求：**

- 建一个数据库 `login_demo`
- 建一张表 `users`，包含 `username`、`password`
- 预先插入以下两个账号（实验用）：

| username | password |
| -------- | -------- |
| admin    | 123456   |
| test     | abc123   |

**导入数据表**

1.打开小皮面板（左侧）

2.找到 **数据库** ，创建一个数据库 `login_demo`，用户名密码自定义

3.点 **“导入”**，点击“选择文件”，选择准备好的 **create_login_demo.sql**

```sql
CREATE DATABASE IF NOT EXISTS login_demo DEFAULT CHARSET utf8mb4;
USE login_demo;

DROP TABLE IF EXISTS users;
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(50)
);

INSERT INTO users (username, password) VALUES
('admin', '123456'),
('test', 'abc123');
```

**创建login.html及login.php**

示例代码

login.html

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>登录实验</title>
</head>
<body>
    <h2>登录小实验（最简单版）</h2>

    <form method="post" action="login.php">
        <label>用户名：</label>
        <input type="text" name="username" required><br><br>

        <label>密码：</label>
        <input type="password" name="password" required><br><br>

        <button type="submit">登录</button>
    </form>
</body>
</html>
```

login.php

```php
<?php
// 获取用户输入
$user = $_POST['username'];
$pass = $_POST['password'];

// 连接数据库
$conn = mysqli_connect("localhost", "demo", "demo123", "login_demo");

if (!$conn) {
    die("数据库连接失败：" . mysqli_connect_error());
}

// 拼接 SQL（教学用，不安全）
$sql = "SELECT * FROM users WHERE username='$user' AND password='$pass'";

$result = mysqli_query($conn, $sql);

// 判断是否匹配
if (mysqli_num_rows($result) > 0) {
    echo "登录成功！欢迎你：" . htmlspecialchars($user);
} else {
    echo "用户名或密码错误";
}

// 关闭连接
mysqli_close($conn);
?>
```

**尝试登录**

将上述代码复制到小皮面板网站根目录，浏览器访问

```http
http://127.0.0.1/login.html
```

输出`admin/123456`尝试登录

**实验思考**

改进为更加安全的形式？

**导入数据**

```sql
CREATE DATABASE IF NOT EXISTS login_demo DEFAULT CHARSET utf8mb4;
USE login_demo;

DROP TABLE IF EXISTS users;
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    password VARCHAR(255) NOT NULL
);

-- 用 PHP password_hash 生成的密码哈希
INSERT INTO users (username, password) VALUES
('admin', '$2y$10$0OBATJE0d6Iya4v7NKSgeoDn45yOOkRXVvK5ynUXWxNoVqKV1R8Sy'),  -- 密码：admin123
('test',  '$2y$10$QKtGtZy61AExYmWlXslJ8u.xety29a8/qW24MJfv2Ln6ZP.ZdOTzi');  -- 密码：test123
```

**login.php**

```php
<?php
// 获取输入
$user = $_POST['username'];
$pass = $_POST['password'];

// 连接数据库
$conn = new mysqli("localhost", "demo", "demo123", "login_demo2");
if ($conn->connect_error) {
    die("数据库连接失败：" . $conn->connect_error);
}

// 使用预处理查询用户名（不查询密码明文）
$stmt = $conn->prepare("SELECT password FROM users WHERE username = ?");
$stmt->bind_param("s", $user);
$stmt->execute();

// 获取结果
$result = $stmt->get_result();

if ($result->num_rows === 1) {
    $row = $result->fetch_assoc();
    $hash = $row['password'];

    // 验证密码
    if (password_verify($pass, $hash)) {
        echo "登录成功！欢迎你：" . htmlspecialchars($user);
    } else {
        echo "用户名或密码错误！";
    }
} else {
    echo "用户名或密码错误！";
}

// 关闭连接
$stmt->close();
$conn->close();
?>
```

能否提供注册功能？

**register.php**

```php
<?php
$user = $_POST['username'];
$pass = $_POST['password'];

// 哈希密码
$hash = password_hash($pass, PASSWORD_DEFAULT);

$conn = new mysqli("localhost", "root", "", "login_demo");
if ($conn->connect_error) {
    die("连接失败：" . $conn->connect_error);
}

// 使用预处理插入
$stmt = $conn->prepare("INSERT INTO users (username, password) VALUES (?, ?)");
$stmt->bind_param("ss", $user, $hash);

if ($stmt->execute()) {
    echo "注册成功！";
} else {
    echo "注册失败：" . $conn->error;
}

$stmt->close();
$conn->close();
?>
```







